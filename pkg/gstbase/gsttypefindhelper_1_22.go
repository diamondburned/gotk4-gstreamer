// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gst/base/base.h>
import "C"

// TypeFindHelperForBufferWithCaps tries to find if type of media contained in
// the given Buffer, matches caps specified, assumption being that the buffer
// represents the beginning of the stream or file.
//
// Tries to find what type of data is contained in the given data, the
// assumption being that the data represents the beginning of the stream or
// file.
//
// Only the typefinder matching the given caps will be called, if found. The
// caps with the highest probability will be returned, or NULL if the content of
// the data could not be identified.
//
// Free-function: gst_caps_unref.
//
// The function takes the following parameters:
//
//   - obj (optional): object doing the typefinding, or NULL (used for logging).
//   - buf with data to typefind.
//   - caps of the media.
//
// The function returns the following values:
//
//   - prob (optional): location to store the probability of the found caps,
//     or NULL.
//   - ret (optional) corresponding to the data, or NULL if no type could be
//     found. The caller should free the caps returned with gst_caps_unref().
//
func TypeFindHelperForBufferWithCaps(obj gst.GstObjector, buf *gst.Buffer, caps *gst.Caps) (gst.TypeFindProbability, *gst.Caps) {
	var _arg1 *C.GstObject             // out
	var _arg2 *C.GstBuffer             // out
	var _arg3 *C.GstCaps               // out
	var _arg4 C.GstTypeFindProbability // in
	var _cret *C.GstCaps               // in

	if obj != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(obj).Native()))
	}
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_type_find_helper_for_buffer_with_caps(_arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(obj)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(caps)

	var _prob gst.TypeFindProbability // out
	var _ret *gst.Caps                // out

	_prob = gst.TypeFindProbability(_arg4)
	if _cret != nil {
		_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _prob, _ret
}

// TypeFindHelperForDataWithCaps tries to find if type of media contained in
// the given data, matches the caps specified, assumption being that the data
// represents the beginning of the stream or file.
//
// Only the typefinder matching the given caps will be called, if found. The
// caps with the highest probability will be returned, or NULL if the content of
// the data could not be identified.
//
// Free-function: gst_caps_unref.
//
// The function takes the following parameters:
//
//   - obj (optional): object doing the typefinding, or NULL (used for logging).
//   - data: pointer with data to typefind.
//   - caps of the media.
//
// The function returns the following values:
//
//   - prob (optional): location to store the probability of the found caps,
//     or NULL.
//   - ret (optional) corresponding to the data, or NULL if no type could be
//     found. The caller should free the caps returned with gst_caps_unref().
//
func TypeFindHelperForDataWithCaps(obj gst.GstObjector, data []byte, caps *gst.Caps) (gst.TypeFindProbability, *gst.Caps) {
	var _arg1 *C.GstObject // out
	var _arg2 *C.guint8    // out
	var _arg3 C.gsize
	var _arg4 *C.GstCaps               // out
	var _arg5 C.GstTypeFindProbability // in
	var _cret *C.GstCaps               // in

	if obj != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(obj).Native()))
	}
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_type_find_helper_for_data_with_caps(_arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(obj)
	runtime.KeepAlive(data)
	runtime.KeepAlive(caps)

	var _prob gst.TypeFindProbability // out
	var _ret *gst.Caps                // out

	_prob = gst.TypeFindProbability(_arg5)
	if _cret != nil {
		_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _prob, _ret
}

// TypeFindListFactoriesForCaps tries to find the best TypeFindFactory
// associated with caps.
//
// The typefinder that can handle caps will be returned.
//
// Free-function: g_list_free.
//
// The function takes the following parameters:
//
//   - obj (optional): object doing the typefinding, or NULL (used for logging).
//   - caps of the media.
//
// The function returns the following values:
//
//   - list (optional) of TypeFindFactory corresponding to caps, or NULL if
//     no typefinder could be found. Caller should free the returned list with
//     g_list_free() and list elements with gst_object_unref().
//
func TypeFindListFactoriesForCaps(obj gst.GstObjector, caps *gst.Caps) []*gst.TypeFindFactory {
	var _arg1 *C.GstObject // out
	var _arg2 *C.GstCaps   // out
	var _cret *C.GList     // in

	if obj != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(obj).Native()))
	}
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_type_find_list_factories_for_caps(_arg1, _arg2)
	runtime.KeepAlive(obj)
	runtime.KeepAlive(caps)

	var _list []*gst.TypeFindFactory // out

	if _cret != nil {
		_list = make([]*gst.TypeFindFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.GstTypeFindFactory)(v)
			var dst *gst.TypeFindFactory // out
			{
				obj := coreglib.AssumeOwnership(unsafe.Pointer(src))
				dst = &gst.TypeFindFactory{
					PluginFeature: gst.PluginFeature{
						GstObject: gst.GstObject{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
						},
					},
				}
			}
			_list = append(_list, dst)
		})
	}

	return _list
}
