// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeNavigationModifierType = coreglib.Type(C.gst_navigation_modifier_type_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNavigationModifierType, F: marshalNavigationModifierType},
	})
}

// NavigationModifierType flags to indicate the state of modifier keys and mouse
// buttons in events.
//
// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
// Apple, CapsLock or ShiftLock.
type NavigationModifierType C.guint

const (
	NavigationModifierNone NavigationModifierType = 0b0
	// NavigationModifierShiftMask: shift key.
	NavigationModifierShiftMask NavigationModifierType = 0b1
	// NavigationModifierButton3Mask: third mouse button (usually the mouse
	// wheel button or middle button).
	NavigationModifierButton3Mask NavigationModifierType = 0b10000000000
	// NavigationModifierMod5Mask: seventh modifier key.
	NavigationModifierMod5Mask NavigationModifierType = 0b10000000
	// NavigationModifierHyperMask: hyper modifier.
	NavigationModifierHyperMask NavigationModifierType = 0b1000000000000000000000000000
	// NavigationModifierMod2Mask: fourth modifier key.
	NavigationModifierMod2Mask NavigationModifierType = 0b10000
	NavigationModifierLockMask NavigationModifierType = 0b10
	// NavigationModifierButton4Mask: fourth mouse button (typically the "Back"
	// button).
	NavigationModifierButton4Mask NavigationModifierType = 0b100000000000
	// NavigationModifierButton1Mask: first mouse button (usually the left
	// button).
	NavigationModifierButton1Mask NavigationModifierType = 0b100000000
	// NavigationModifierMetaMask: meta modifier.
	NavigationModifierMetaMask NavigationModifierType = 0b10000000000000000000000000000
	// NavigationModifierMod3Mask: fifth modifier key.
	NavigationModifierMod3Mask NavigationModifierType = 0b100000
	// NavigationModifierControlMask: control key.
	NavigationModifierControlMask NavigationModifierType = 0b100
	// NavigationModifierButton5Mask: fifth mouse button (typically the
	// "forward" button).
	NavigationModifierButton5Mask NavigationModifierType = 0b1000000000000
	// NavigationModifierMask: mask covering all entries in ModifierType.
	NavigationModifierMask NavigationModifierType = 0b11100000000000001111111111111
	// NavigationModifierButton2Mask: second mouse button (usually the right
	// button).
	NavigationModifierButton2Mask NavigationModifierType = 0b1000000000
	// NavigationModifierMod4Mask: sixth modifier key.
	NavigationModifierMod4Mask NavigationModifierType = 0b1000000
	// NavigationModifierSuperMask: super modifier.
	NavigationModifierSuperMask NavigationModifierType = 0b100000000000000000000000000
	// NavigationModifierMod1Mask: third modifier key.
	NavigationModifierMod1Mask NavigationModifierType = 0b1000
)

func marshalNavigationModifierType(p uintptr) (interface{}, error) {
	return NavigationModifierType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for NavigationModifierType.
func (n NavigationModifierType) String() string {
	if n == 0 {
		return "NavigationModifierType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for n != 0 {
		next := n & (n - 1)
		bit := n - next

		switch bit {
		case NavigationModifierNone:
			builder.WriteString("None|")
		case NavigationModifierShiftMask:
			builder.WriteString("ShiftMask|")
		case NavigationModifierButton3Mask:
			builder.WriteString("Button3Mask|")
		case NavigationModifierMod5Mask:
			builder.WriteString("Mod5Mask|")
		case NavigationModifierHyperMask:
			builder.WriteString("HyperMask|")
		case NavigationModifierMod2Mask:
			builder.WriteString("Mod2Mask|")
		case NavigationModifierLockMask:
			builder.WriteString("LockMask|")
		case NavigationModifierButton4Mask:
			builder.WriteString("Button4Mask|")
		case NavigationModifierButton1Mask:
			builder.WriteString("Button1Mask|")
		case NavigationModifierMetaMask:
			builder.WriteString("MetaMask|")
		case NavigationModifierMod3Mask:
			builder.WriteString("Mod3Mask|")
		case NavigationModifierControlMask:
			builder.WriteString("ControlMask|")
		case NavigationModifierButton5Mask:
			builder.WriteString("Button5Mask|")
		case NavigationModifierMask:
			builder.WriteString("Mask|")
		case NavigationModifierButton2Mask:
			builder.WriteString("Button2Mask|")
		case NavigationModifierMod4Mask:
			builder.WriteString("Mod4Mask|")
		case NavigationModifierSuperMask:
			builder.WriteString("SuperMask|")
		case NavigationModifierMod1Mask:
			builder.WriteString("Mod1Mask|")
		default:
			builder.WriteString(fmt.Sprintf("NavigationModifierType(0b%b)|", bit))
		}

		n = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if n contains other.
func (n NavigationModifierType) Has(other NavigationModifierType) bool {
	return (n & other) == other
}

// NavigationEventGetCoordinates: try to retrieve x and y coordinates of a
// Navigation event.
//
// The function takes the following parameters:
//
//   - event to inspect.
//
// The function returns the following values:
//
//   - x (optional): pointer to a gdouble to receive the x coordinate of the
//     navigation event.
//   - y (optional): pointer to a gdouble to receive the y coordinate of the
//     navigation event.
//   - ok: boolean indicating success.
//
func NavigationEventGetCoordinates(event *gst.Event) (x, y float64, ok bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 C.gdouble   // in
	var _arg3 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_get_coordinates(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(event)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg2)
	_y = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// NavigationEventNewCommand: create a new navigation event given navigation
// command..
//
// The function takes the following parameters:
//
//   - command: navigation command to use.
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewCommand(command NavigationCommand) *gst.Event {
	var _arg1 C.GstNavigationCommand // out
	var _cret *C.GstEvent            // in

	_arg1 = C.GstNavigationCommand(command)

	_cret = C.gst_navigation_event_new_command(_arg1)
	runtime.KeepAlive(command)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewKeyPress: create a new navigation event for the given key
// press.
//
// The function takes the following parameters:
//
//   - key: string identifying the key press.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewKeyPress(key string, state NavigationModifierType) *gst.Event {
	var _arg1 *C.gchar                    // out
	var _arg2 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_key_press(_arg1, _arg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewKeyRelease: create a new navigation event for the given key
// release.
//
// The function takes the following parameters:
//
//   - key: string identifying the released key.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewKeyRelease(key string, state NavigationModifierType) *gst.Event {
	var _arg1 *C.gchar                    // out
	var _arg2 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_key_release(_arg1, _arg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewMouseButtonPress: create a new navigation event for the
// given key mouse button press.
//
// The function takes the following parameters:
//
//   - button: number of the pressed mouse button.
//   - x coordinate of the mouse cursor.
//   - y coordinate of the mouse cursor.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewMouseButtonPress(button int, x, y float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.gint                      // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.gdouble                   // out
	var _arg4 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.gint(button)
	_arg2 = C.gdouble(x)
	_arg3 = C.gdouble(y)
	_arg4 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_mouse_button_press(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(button)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewMouseButtonRelease: create a new navigation event for the
// given key mouse button release.
//
// The function takes the following parameters:
//
//   - button: number of the released mouse button.
//   - x coordinate of the mouse cursor.
//   - y coordinate of the mouse cursor.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewMouseButtonRelease(button int, x, y float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.gint                      // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.gdouble                   // out
	var _arg4 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.gint(button)
	_arg2 = C.gdouble(x)
	_arg3 = C.gdouble(y)
	_arg4 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_mouse_button_release(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(button)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewMouseMove: create a new navigation event for the new mouse
// location.
//
// The function takes the following parameters:
//
//   - x coordinate of the mouse cursor.
//   - y coordinate of the mouse cursor.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewMouseMove(x, y float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.gdouble                   // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.gdouble(x)
	_arg2 = C.gdouble(y)
	_arg3 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_mouse_move(_arg1, _arg2, _arg3)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewMouseScroll: create a new navigation event for the mouse
// scroll.
//
// The function takes the following parameters:
//
//   - x coordinate of the mouse cursor.
//   - y coordinate of the mouse cursor.
//   - deltaX: x component of the scroll movement.
//   - deltaY: y component of the scroll movement.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewMouseScroll(x, y, deltaX, deltaY float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.gdouble                   // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.gdouble                   // out
	var _arg4 C.gdouble                   // out
	var _arg5 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.gdouble(x)
	_arg2 = C.gdouble(y)
	_arg3 = C.gdouble(deltaX)
	_arg4 = C.gdouble(deltaY)
	_arg5 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_mouse_scroll(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(deltaX)
	runtime.KeepAlive(deltaY)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewTouchCancel: create a new navigation event signalling that
// all currently active touch points are cancelled and should be discarded.
// For example, under Wayland this event might be sent when a swipe passes the
// threshold to be recognized as a gesture by the compositor.
//
// The function takes the following parameters:
//
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewTouchCancel(state NavigationModifierType) *gst.Event {
	var _arg1 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_touch_cancel(_arg1)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewTouchDown: create a new navigation event for an added touch
// point.
//
// The function takes the following parameters:
//
//   - identifier: number uniquely identifying this touch point. It must stay
//     unique to this touch point at least until an up event is sent for the
//     same identifier, or all touch points are cancelled.
//   - x coordinate of the new touch point.
//   - y coordinate of the new touch point.
//   - pressure: pressure data of the touch point, from 0.0 to 1.0, or NaN if no
//     data is available.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewTouchDown(identifier uint, x, y, pressure float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.guint                     // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.gdouble                   // out
	var _arg4 C.gdouble                   // out
	var _arg5 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.guint(identifier)
	_arg2 = C.gdouble(x)
	_arg3 = C.gdouble(y)
	_arg4 = C.gdouble(pressure)
	_arg5 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_touch_down(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(identifier)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(pressure)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewTouchFrame: create a new navigation event signalling
// the end of a touch frame. Touch frames signal that all previous down,
// motion and up events not followed by another touch frame event already should
// be considered simultaneous.
//
// The function takes the following parameters:
//
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewTouchFrame(state NavigationModifierType) *gst.Event {
	var _arg1 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_touch_frame(_arg1)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewTouchMotion: create a new navigation event for a moved
// touch point.
//
// The function takes the following parameters:
//
//   - identifier: number uniquely identifying this touch point. It must
//     correlate to exactly one previous touch_start event.
//   - x coordinate of the touch point.
//   - y coordinate of the touch point.
//   - pressure: pressure data of the touch point, from 0.0 to 1.0, or NaN if no
//     data is available.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewTouchMotion(identifier uint, x, y, pressure float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.guint                     // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.gdouble                   // out
	var _arg4 C.gdouble                   // out
	var _arg5 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.guint(identifier)
	_arg2 = C.gdouble(x)
	_arg3 = C.gdouble(y)
	_arg4 = C.gdouble(pressure)
	_arg5 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_touch_motion(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(identifier)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(pressure)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NavigationEventNewTouchUp: create a new navigation event for a removed touch
// point.
//
// The function takes the following parameters:
//
//   - identifier: number uniquely identifying this touch point. It must
//     correlate to exactly one previous down event, but can be reused after
//     sending this event.
//   - x coordinate of the touch point.
//   - y coordinate of the touch point.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - event: new Event.
//
func NavigationEventNewTouchUp(identifier uint, x, y float64, state NavigationModifierType) *gst.Event {
	var _arg1 C.guint                     // out
	var _arg2 C.gdouble                   // out
	var _arg3 C.gdouble                   // out
	var _arg4 C.GstNavigationModifierType // out
	var _cret *C.GstEvent                 // in

	_arg1 = C.guint(identifier)
	_arg2 = C.gdouble(x)
	_arg3 = C.gdouble(y)
	_arg4 = C.GstNavigationModifierType(state)

	_cret = C.gst_navigation_event_new_touch_up(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(identifier)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(state)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// The function takes the following parameters:
//
//   - event to modify.
//   - state: bit-mask representing the state of the modifier keys (e.g.
//     Control, Shift and Alt).
//
// The function returns the following values:
//
//   - ok: TRUE if the event is a Navigation event with associated modifiers
//     state, otherwise FALSE.
//
func NavigationEventParseModifierState(event *gst.Event, state *NavigationModifierType) bool {
	var _arg1 *C.GstEvent                  // out
	var _arg2 *C.GstNavigationModifierType // out
	var _cret C.gboolean                   // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg2 = (*C.GstNavigationModifierType)(unsafe.Pointer(state))

	_cret = C.gst_navigation_event_parse_modifier_state(_arg1, _arg2)
	runtime.KeepAlive(event)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NavigationEventParseTouchEvent: retrieve the details of a Navigation
// touch-down or touch-motion event. Determine which type the event is using
// gst_navigation_event_get_type() to retrieve the NavigationEventType.
//
// The function takes the following parameters:
//
//   - event to inspect.
//
// The function returns the following values:
//
//   - identifier (optional): pointer to a guint that will receive the
//     identifier unique to this touch point.
//   - x (optional): pointer to a gdouble that will receive the x coordinate of
//     the touch event.
//   - y (optional): pointer to a gdouble that will receive the y coordinate of
//     the touch event.
//   - pressure (optional): pointer to a gdouble that will receive the force of
//     the touch event, in the range from 0.0 to 1.0. If pressure data is not
//     available, NaN will be set instead.
//   - ok: TRUE if all details could be extracted, otherwise FALSE.
//
func NavigationEventParseTouchEvent(event *gst.Event) (identifier uint, x, y, pressure float64, ok bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 C.guint     // in
	var _arg3 C.gdouble   // in
	var _arg4 C.gdouble   // in
	var _arg5 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_parse_touch_event(_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(event)

	var _identifier uint  // out
	var _x float64        // out
	var _y float64        // out
	var _pressure float64 // out
	var _ok bool          // out

	_identifier = uint(_arg2)
	_x = float64(_arg3)
	_y = float64(_arg4)
	_pressure = float64(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _identifier, _x, _y, _pressure, _ok
}

// NavigationEventParseTouchUpEvent: retrieve the details of a Navigation
// touch-up event.
//
// The function takes the following parameters:
//
//   - event to inspect.
//
// The function returns the following values:
//
//   - identifier (optional): pointer to a guint that will receive the
//     identifier unique to this touch point.
//   - x (optional): pointer to a gdouble that will receive the x coordinate of
//     the touch event.
//   - y (optional): pointer to a gdouble that will receive the y coordinate of
//     the touch event.
//   - ok: TRUE if all details could be extracted, otherwise FALSE.
//
func NavigationEventParseTouchUpEvent(event *gst.Event) (identifier uint, x, y float64, ok bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 C.guint     // in
	var _arg3 C.gdouble   // in
	var _arg4 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_parse_touch_up_event(_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _identifier uint // out
	var _x float64       // out
	var _y float64       // out
	var _ok bool         // out

	_identifier = uint(_arg2)
	_x = float64(_arg3)
	_y = float64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _identifier, _x, _y, _ok
}

// NavigationEventSetCoordinates: try to set x and y coordinates on a Navigation
// event. The event must be writable.
//
// The function takes the following parameters:
//
//   - event to modify.
//   - x coordinate to set.
//   - y coordinate to set.
//
// The function returns the following values:
//
//   - ok: boolean indicating success.
//
func NavigationEventSetCoordinates(event *gst.Event, x, y float64) bool {
	var _arg1 *C.GstEvent // out
	var _arg2 C.gdouble   // out
	var _arg3 C.gdouble   // out
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg2 = C.gdouble(x)
	_arg3 = C.gdouble(y)

	_cret = C.gst_navigation_event_set_coordinates(_arg1, _arg2, _arg3)
	runtime.KeepAlive(event)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
